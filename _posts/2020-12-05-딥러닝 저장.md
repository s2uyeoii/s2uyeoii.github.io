---
layout: post
title: deep
subtitle: 
comments: true
tags: [software] 
---

from keras import optimizers
from keras.datasets import cifar10
from keras.engine import Model
from keras.layers import Dropout, Flatten, Dense
from keras.utils import np_utils
import efficientnet.keras as efn 
img_width, img_height= 32, 32
base_model= efn.EfficientNetB0(weights='imagenet', include_top=False, input_shape=(32, 32, 3))
epochs = 70    # 50 is good
nb_classes= 10
import os
import matplotlib.pyplot as plt
model_type = 'EfficientnetB0'
import math
import matplotlib.pyplot as plt
import random
import numpy as np
from keras.models import load_model

# load dataset
(X_train, y_train), (X_test, y_test) = cifar10.load_data()
y_train= np_utils.to_categorical(y_train, nb_classes)
y_test= np_utils.to_categorical(y_test, nb_classes)# Extract the last layer from third block of model
last = base_model.get_layer('top_activation').output# Add classification layers on top of it
x = Flatten()(last)
x = Dense(256, activation='relu')(x)
x = Dropout(0.5)(x)
output = Dense(10, activation='softmax')(x)
model = Model(base_model.input, output)

model.compile(loss='binary_crossentropy',optimizer=optimizers.SGD(lr=1e-3, momentum=0.9),metrics=['accuracy'])
model.summary()
print(model_type)
model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=epochs, batch_size=200, verbose=1)

# Final evaluation of the model
scores = model.evaluate(X_test, y_test, verbose=0)
print("loss: %.2f" % scores[0])
print("acc: %.2f" % scores[1])

print("loss: %.2f" % scores[0])
print("Test accuracy: %.2f" % scores[1])

model.save('DL_resnet.h5')

from google.colab import files
files.download('DL_resnet.h5')

%matplotlib inline
import math
import matplotlib.pyplot as plt
import random

(x_train, y_train), (x_test, y_test) = cifar10.load_data()
model = load_model('DL_resnet.h5')

# Get one and predict
r = random.randint(0, 10000 - 1)
input_val = x_test[r:r+1]
output_val = model.predict(input_val)

print("Prediction : ", np.argmax(output_val))

# Selected sample showing
plt.imshow(
    input_val.reshape(32, 32,3),
    interpolation='nearest')
plt.show()
